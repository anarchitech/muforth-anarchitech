( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

loading EFM8 serial bootloader

ld target/common/endian.mu4
ld lib/crc16.mu4
ld target/common/serial.mu4

hex

( Usual comm basics.)
: >b  send ;
: b>  recv ;

: >w  >lohi  >b >b ;  ( big-endian)

( To make spying on the protocol easier to deal with, break up the printed
  bytes into "packets" in a semantically meaningful way. How about this
  stupid name, which is easy to remember:)

: ?spkt  ( spy packet, or "spiked")  spy @ if  cr  then ;


( The command format is very simple:

  $ <len> <cmd> ...

  len is the byte count of everything following the '$'. Multibyte values
  are sent big-endian: high bytes first.)

( Commands: [all values are in hex]

  Cmd  Data...                       Returns   Explanation
  ===  ==========================    =======   ===================================
  Identify  30  id0 id1                       40, 42    Query if the part id matches
  Setup     31  a5 f1 00                      40        Setup flash keys and bank#
  Erase     32  <addr> <data, 0-128 bytes>    40, 41    Erase and optionally write to flash
  Write     33  <addr> <data, 1-128 bytes>    40, 41    Write to flash
  Verify    34  <addr1> <addr2> <crc>         40, 43    Compute CRC16 from addr1 to addr2 [inclusive]
  Lock      35  <sig> <lock>                            Lock the flash; we are going to ignore this
  Run       36  00 00                         40        Reset and start executing from flash vector

  Return values are:
  40  ACK - Everything Ok
  41  Range error
  42  Bad id error
  43  CRC error
  )

: ?ack  b> dup 40 = if drop ^ then
           dup 41 = if drop error" Range error" then
           dup 42 = if drop error" Bad chip id" then
               43 = if      error" CRC mismatch" then ;

: >buf  ( a u)        for  c@+ swap >b  next drop ;
: crc   ( a u - crc)  ffff -rot  crc16-buf ;

( #bytes is the count of bytes in the *payload*. We add 1 to include the
  command byte in the total count.)

: >cmd  ( #bytes cmd)  ?spkt  char $ >b  >b  1+ ( count cmd byte) >b ;
: <flash>  ( a u cmd)   over 2 + swap >cmd  over >w ( addr)  >buf  ?ack ;

: b.identify  ( chip)  2  30  >cmd  >w                                               ?ack ;
: b.setup              3  31  >cmd  a5f1 >w ( keys)  00 >b ( bank)                   ?ack ;
: b.erase     ( a u)      32  <flash> ;
: b.write     ( a u)      33  <flash> ;
: b.verify    ( a u)   6  34  >cmd  over >w ( addr1)  2dup + 1- >w ( addr2)  crc >w  ?ack ;
: b.run                2  36  >cmd  0 >w                                             ?ack ;

( This is really just for testing - initially with an EFM8BB1LCK board.)
: hi
   #115200 bps  drain  flush
   3001 ( device and derivative id for EFM8BB10F8G_QSOP) b.identify ;
