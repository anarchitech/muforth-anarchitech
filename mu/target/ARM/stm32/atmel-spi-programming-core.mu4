( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

loading Atmel SPI flash programming (STM32 core)

( It might seem rather odd that this is here, but I'm interested in using
  an STM32 Discovery board as a "programming pod" for Atmel 8051 and AVR
  microcontrollers, which have a simple SPI interface for erasing,
  programming, and reading the on-chip memories and configuration bytes.

  The AVR and AT89LP [Atmel's 8051 variant] have similar but not identical
  command protocols. I'm thinking of leaving the details to the host, and
  putting just the "plumbing" here.

  The idea is basically this:

  [1] the STM32 chip sits in a loop, reading a word of the RAM until a
  magic number appears there. This is the "semaphore" signal from the host
  that a command packet is available. When it sees the magic word, it goes
  to step 2.

  [2] The STM32 turns around and talks to the target chip via SPI, sending
  the command, address, and any data bytes to the target, and reading its
  response. It buffers the response, and then writes a different magic number
  to the semaphore word, signaling the host that it has completed the
  command.

  Then it goes back to [1]. The host reads the buffered target response,
  creates a new command packet, and sets the semaphore word.

  The communication between the STM32 and the host can be over ST-LINK,
  which means that no USB-serial interface is necessary. The STM32 Discovery
  board can power the target as well.

  There is no need to flash this code into the STM32. It can easily run
  from RAM.)

__meta
decimal

( The ST-LINK code will have written some flash programming routines into
  ram. We don't need these, so let's back up over them and start fresh.)

ram  wipe

( We want to put the data structures that the host will use to communicate
  with the STM32 at the beginning of RAM so we know where to find them.
  Remember: when *using* this code, the host will have loaded AVR or 8051
  code into the memory spaces. It will have no idea about how the memory of
  the STM32 is laid out, so we set up a simple, constant layout - data first,
  then the program.)

( Let's put the big stuff first. Makes it easy to find when debugging.)
here equ data        256 allot  ( memory read/write buffer)
here equ semaphore  cell allot  ( semaphore + stm32 command)

here equ cmd           1 allot  ( flash command)
here equ addr                   ( flash addr)
here equ addr-hi       1 allot
here equ addr-lo       1 allot
here equ result                 ( single byte result)
here equ toggle        1 allot  ( flash command toggle - for AVR)
here equ count                  ( byte count to transfer)
here equ out-count     2 allot  ( byte count to write)
here equ in-count      2 allot  ( byte count to read)

hex

( We want to write this code in Forth, so let's load the Forth kernel.)
ld target/ARM/v6-m/kernel-itc.mu4

-- ------------------------------------------------------------------------
-- Chip init
-- ------------------------------------------------------------------------
.ifdef stm32f072
   #48,000,000 equ cpuclk
   ld target/ARM/stm32/f0/72_b-init.mu4
.then
.ifdef stm32f303
   #72,000,000 equ cpuclk
   ld target/ARM/stm32/f3/03_c-init.mu4
.then

: spi-init
   -- First, enable clocks to Port B. We are using SPI1 on pins PB3, PB4, and
   -- PB5, and using PB6 and PB7 as GPIO pins (target /SS, target /RST, resp.)
   ( Ports -FED_CBA- )
        [ %0000_0100  #16 << #] RCC_AHBENR set!

   -- Clear port B
   0 GPIOB_ODR !
   -- Set PB3, 5, 6, and 7 to output.
   0 GPIOB_MODER !
   [ %0101_0100_01  3 2* << #] GPIOB_MODER set!  ( 2 bits per pin)
   -- Set output speed to medium.
   0 GPIOB_OSPEEDR !
   [ %0101_0100_01  3 2* << #] GPIOB_OSPEEDR set!  ( 2 bits per pin) ;

-- --------------------------------------------------------------------
-- SPI building blocks
-- --------------------------------------------------------------------
: bit/  ( bit)  GPIOB_BSRR ! ;
: bit\  ( bit)  GPIOB_BRR ! ;

( SCK on PB3.)
: sck/   [ 1 3 << #] bit/ ;
: sck\   [ 1 3 << #] bit\ ;

( Half cycle delay. Needed to slow the clock down a bit.)
: H ;

( Do one clock cycle, including any delays.)
: sck/\   sck/ H sck\ ;

( XXX Do we care that bit! and bit@, written in Forth, are rather slow? If
  we wanted to bitbang faster, these should be code words.)

( MISO on PB4.)
: bit@   ( bits - bits')
   2*  GPIOB_IDR @  4 >>  1 and  + ;

( Amusing note: The standard Forth-style pronunciation of bit! is "bit bang". ;-)

( MOSI on PB5.)
: bit!   ( bits - bits')  ( sample hi bit - 80 - and drive MOSI with it)
   dup  [ 1 5 << #]  GPIOB_BRR ( bit clear register)
   rot 80 and  if  [ GPIOB_BSRR GPIOB_BRR - #] + ( bit set register)  then  !
   2* ;

( /SS on PB6.)
: ss/  ( de-assert /SS)   [ 1 6 << #] bit/ ;
: ss\  ( assert /SS)      [ 1 6 << #] bit\ ;

( /RST on PB7.)
: rst/  ( de-assert /RST)   [ 1 7 << #] bit/ ;
: rst\  ( assert /RST)      [ 1 7 << #] bit\ ;

( Write a byte.)
: >s   ( b)
   8 for  bit!  sck/\  next  drop ;

( Read a byte.)
: s>   ( - b)
   0  8 for  bit@  sck/\  next ;

( Write and read a byte.)
: >s>  ( out - in)
   0 swap  8 for  bit!  swap bit@ swap  sck/\  next  drop ;


( Since we are going to be reading a buffer sent to us by the host, let's
  have nice words for that.)

variable p
: p@   p @  c@       ;  ( read next byte from buf, don't incr)
: p*   p @  c@+  p ! ;  ( read next byte from buf, incr)
: p&   p @  c!+  p ! ;  ( write next byte to buf, incr)

: >p>   p@ >s> p& ;     ( read from buf, send byte, recv byte, write to buf)
:  p>       s> p& ;     ( send dummy byte, recv byte, write to buf)
: >p    p* >s     ;     ( read from buf, send byte, recv and discard byte)


.ifdef avr
-- ------------------------------------------------------------------------
-- AVR programming
-- ------------------------------------------------------------------------
: send-cmd
   ( Save data pointer, send cmd and addr, restore data pointer.)
   p @  cmd p !  >p >p >p  p !
   ( Toggle cmd.)
   toggle c@  cmd c@  over xor  dup cmd c!
   ( If cmd toggled to zero, or if toggle *is* zero, incr addr-lo.)
   and 0= if  addr-lo dup c@ 1+  swap c!  then ;

: setup-bulk  ( - count)  data p !  count h@ ;

( The three transaction types to define: single, bulk-read, bulk-write.)
: single      cmd p !  >p> >p> >p> >p> ;
: bulk-read   setup-bulk  for  send-cmd  p>  next ;
: bulk-write  setup-bulk  for  send-cmd  >p  next ;

.then  ( avr)


.ifdef at89lp
-- ------------------------------------------------------------------------
-- AT89LP programming using fixed-length payloads, no prefix, no /SS
-- ------------------------------------------------------------------------
( Mostly for the AT89LP51/52.)

( This version does *not* use /SS or the 0aa 55 prefix, and the data
  payload is always either 1 byte or 64 bytes.)

( TODO)
( The three transaction types to define: single, bulk-read, bulk-write.)
: single ;
: bulk-read ;
: bulk-write ;

.then  ( at89lp)


.ifdef at89lp-ss
-- ------------------------------------------------------------------------
-- AT89LP programming using variable-length payload, command prefix, and /SS
-- ------------------------------------------------------------------------
( For AT89LP828, 3240, 6440.)

( This version uses SPI slave select [/SS] to bracket the command packet,
  and also prefixes every command with 0aa 55.)

( Start an SPI packet, send the prefix bytes, setup command buffer.)
: <pkt   ss\  0aa >s  55 >s  cmd p ! ;

( End a programming packet.)
: pkt>   ss/ ;

( Send cmd, addr-hi, and addr-lo, discarding responses. Setup data buffer.)
: setup-bulk  ( - count)  <pkt  >p >p >p  data p !  count h@ ;

( The three transaction types to define: single, bulk-read, bulk-write.)

( Send cmd, addr-hi, addr-lo, and one dummy byte, saving all responses.)
: single       <pkt  >p> >p> >p> p>  pkt> ;

( For bulk commands, send cmd and address bytes, then send or recv a
  buffer of data.)

: bulk-read    setup-bulk  for  p>  next  pkt> ;
: bulk-write   setup-bulk  for  >p  next  pkt> ;

.then  ( at89lp-ss)


-- ------------------------------------------------------------------------
-- Serial communication - UART
-- ------------------------------------------------------------------------
: uart-init
   -- First, enable clocks to Port A. We are using uart1 on pins PA9 and PA10.
   [ 1 #17 << #] RCC_AHBENR set!

   -- Enable clocks to uart1 as well.
   [ 1 #14 << #] RCC_APB2ENR set!

   -- Set mode bits (%10) and alternate function (AF1) for uart.
   [ %1010 #9       2*  << #] GPIOA_MODER set!  ( 2 bits per pin)
   [    11 #9  8 -  4 * << #] GPIOA_AFRH set!   ( 4 bits per pin)

   -- Now for the uart itself.
   USART1_CR1  0 over ! ( reset and disable USART)
   %1100 ( TE+RE) ( enable tx and rx)  over set!
   [ cpuclk #38,400 / #] USART1_BRR !
   1 ( UE) ( enable USART)  swap set! ;

: ?status  ( bit)
   begin  USART1_ISR @  over and  until  drop ;

: uart-recv  ( - b)   [ 1 #5 << ( RXNE bit) #] ?status  USART1_RDR @ ;
: uart-send  ( b)     [ 1 #7 << ( TXE bit)  #] ?status  USART1_TDR ! ;

: uart-send-recv
   data p !  out-count h@ for  p* uart-send  next
   data p !   in-count h@ for  uart-recv p&  next ;


-- ------------------------------------------------------------------------
-- Serial communication - I2C
-- ------------------------------------------------------------------------
: i2c-init
   -- We are using I2C2, with SCL on PB10, SDA on PB11. spi-init has turned
   -- on the PortB clock.

   -- Enable clocks to ic2c.
   [ 1 #22 << #] RCC_APB1ENR set!

   -- Set mode bits (%10) and alternate function (AF1) for i2c2.
   [ %1010 #10       2*  << #] GPIOB_MODER set!  ( 2 bits per pin)
   [    11 #10  8 -  4 * << #] GPIOB_AFRH set!   ( 4 bits per pin)

   -- I'm not sure if setting the pins to alternate function causes them to
   -- be open-drain, so to be sure, let's set that as well.
   [   %11 #10           << #] GPIOB_OTYPER set!  ( 1 bit per pin)

   -- Now for the I2C itself.
   I2C2_CR1  0 over ! ( reset and disable I2C)
   -- Timing info from Table 95 of RM0091 manual. We want to run 100kHz
   -- "standard mode" clock. Here are the recomended settings, based on a
   -- 48M clock (values are in hex):
   -- PRESC=0b    /12, so 4 MHz clock (250ns per cycle)
   -- SCLDEL=04    5 cycles = 1.25us
   -- SDADEL=02    2 cycles = 500ns  ( why isn't this 3 cycles?)
   -- SCLH=0f     16 cycles = 4us
   -- SCLL=13     20 cycles = 5us
   -- b042_0f13 I2C2_TIMINGR !

   -- Let's try some more "relaxed" timing...
   -- SCLDEL=07    8 cycles = 2us
   -- SDADEL=08    8 cycles = 2us
   -- SCLH=13     20 cycles = 5us
   -- SCLL=13     20 cycles = 5us
   b078_1313 I2C2_TIMINGR !

   1 ( PE) ( enable I2C)  swap set! ;

: ?i2c-status  ( mask - status)
   begin  I2C2_ISR @  over and  ?until  nip ;

( I2Cx_ISR bits)
1 1 << equ TXIS
1 2 << equ RXNE
1 4 << equ NACKF
1 5 << equ STOPF
1 6 << equ TC

( I2Cx_CR2 bits)
1 #13 << equ START
1 #14 << equ STOP

: i2c-send  ( b - done?)
   [ TC TXIS + #] ?i2c-status
   TXIS and if  I2C2_TXDR !  0  ^  then  ( TC)  drop ( b)  -1 ;

: i2c-recv  ( - done? b)
   [ TC RXNE + #] ?i2c-status
   RXNE and if  0  I2C2_RXDR @  ^  then  ( TC)  -1 0 ;

: i2c-stop
   STOP I2C2_CR2 set! ( request STOP bit generation)
   STOPF ?i2c-status drop  ( wait for it to happen) ;

( read=1, write=0)
: i2c-start?  ( 'count rd/nwr - nack?)
   ( read=1, write=0) #10 <<
   addr c@ ( slave-addr, low bit 0) +
   over h@ ( count) #16 << +  I2C2_CR2 !
   data p !

   ( See if device responds.)
   1000 ( #tries)
   begin
      [ NACKF STOPF + #] I2C2_ICR !  ( clear any STOPF or NACKF bits)
      START I2C2_CR2 set!
      [ TC NACKF TXIS RXNE + + + #] ?i2c-status
      NACKF and
   while
      ( nack; send STOP bit; delay; try again)
      i2c-stop  100 wait
   1- =until
   ( nacked over and over; give up)
   swap h!  ( status=Bad)  -1 ( nack?)
   then
   ( got something other than nack; continue)
   swap h!  0 ;

: i2c-send-recv
   0 result c!  ( status=Ok)
   out-count      0 ( write)  i2c-start? if ^ then  begin  p* i2c-send  until
   in-count   ?if 1 ( read)   i2c-start? if ^ then  begin  i2c-recv p&  until  then
   i2c-stop  100 wait ( a small delay helps!) ;


-- ------------------------------------------------------------------------
-- Jump tables
-- ------------------------------------------------------------------------
: (dispatch)  ( index)
   1+ cells r@ +
   dup r@ @ u< if  r> drop  @execute ^  then
   drop  r> @ >r  ( skip jump table and keep executing) ;

compiler: [:  ( start a jump table)
   \t (dispatch) ,  here  0 , ( ip past last cfa) ;

compiler: :]  ( end a jump table)
   here  swap  image-! ;


-- ------------------------------------------------------------------------
-- Core command processing loop
-- ------------------------------------------------------------------------
( XXX forget about changing clock speed for now.)
: fast-clock ;
: slow-clock ;

( Command index is above the word that it executes.)
: do-command  ( n)
           ( 10    11       12           13 )
   10 - [:  rst\  rst/  slow-clock  fast-clock
           (  14       15         16 )
            single  bulk-read  bulk-write
           (      17             18 )
            uart-send-recv  i2c-send-recv  :] ;

here ]  ( chip-init)
   clock-init  led-init  spi-init  uart-init  i2c-init  flash-leds
   fast-clock  ss/  rst/  sck\
   begin
      face_d000 semaphore !  ( ready for another command)
      0  begin  drop  semaphore @  dup ffff_ff00 and  deca_f000 =  until
      0ff and  ( command byte)  do-command
   again [

( Startup code! Since we have a Forth kernel, let's write the startup code
  in Forth!)

label startup
   ( Ignore the sp we were passed. Set rp to top of ram, sp below.)
   @ram #ram + rp lit   rp sp mov   #64 cells # sp sp sub
   cpsid  ( disable interrupts)
   ( chip-init)  ip  lit
   deca_fbad     top lit
   next  ;c
   pool,


( XXX The following is for interactive testing and needs to go away
  eventually.)

.ifdef testing

: >lohi  ( w - lo hi)
   dup  0ff and  swap 8 >> ;

: >hilo  ( w - hi lo)
   >lohi swap ;

: lohi>  ( lo hi - w)  8 << + ;

: shuffle  ( cmd addr data - data addr-lo addr-hi cmd)
   -rot  >lohi  rot ;

: index  ( offset)
   100 0 do  dup i +   i data + c!  loop  drop ;

: wipe
   100 0 do  0ff i data + c!  loop ;

.ifdef i2c

: 5ms  [ cpuclk #200 /  #13 / #] wait ;

variable #nacks
: ii  clock-init  led-init  spi-init  i2c-init  flash-leds
      0d0 addr c! ( slave address) rst\  1000 wait  rst/
      0 #nacks ! ;

( send/recv)
: s/r  ( #out #in - continue?)  in-count h!  out-count h!  i2c-send-recv
   result c@  #nacks +! ;

: #out  p @ data - ;

: iv  10 data c! 1 0 s/r  14 data c! 1 4 s/r ;
: isp  13 data c! 1 2 s/r  data c@+ c@ lohi> 1+ ;
: ii-set-addr  ( a)  >hilo 11 data c!+ c!+ c!  3 0 s/r ;
: iaa  ( addr)
  10 for  dup ii-set-addr  next drop ;
: ix  80 0 do    i  data 1+ i +  c!  loop ;
: iz  80 0 do  0ff  data 1+ i +  c!  loop ;
: ixf  ( - #out)  0  40 for  dup p& 1+  dup p& 1+  1 p&  next  drop  #out ;

: ii-rd  ( count space addr)  ii-set-addr  14 + data c!  1 swap s/r ;
: ii-wr  ( count space addr)  ii-set-addr  17 + data c!  ix  1+ 0 s/r ;

: ii-set-flash-cmd  ( cmd - #out)
   data p !  17 p&  0 p& 0 p& ( dummy word)  p& ( cmd)  #out ;

: ii-flash-erase  ( a)
   ii-set-addr
   3 ( erase page) ii-set-flash-cmd  0 s/r ;

: ii-flash-write-words  ( a)
   ii-set-addr
   data p !  17 p&  ixf  0 s/r ;

: ii-flash-write-page  ( a)
   ii-set-addr
   5 ( write-page) ii-set-flash-cmd  0 s/r ;

: ii-flash-enable
   0 ii-set-addr
   11 ( re-enable RWW)  ii-set-flash-cmd  0 s/r ;

: ?nack  #nacks @ if  r> drop  then ;

: ii-wr-flash  ( addr)
   0 #nacks !
   dup ii-flash-erase  ?nack
   dup ii-flash-write-words  ?nack
       ii-flash-write-page  ?nack
   ii-flash-enable ;

: ii-stop   1b data c!  1 0 s/r ;
: ii-start  1a data c!  1 0 s/r ;

.then  ( i2c)

.ifdef at89lp-ss

( Testing. Set things up as if for an at89lp chip.)
: tt
   clock-init  led-init  spi-init  flash-leds
   ss/  sck\ ;

: ss-bulk-setup  ( cmd addr count)  count h!  >lohi rot  cmd  c!+ c!+ c! ;
: ss   ( cmd addr data)   shuffle  cmd c!+ c!+ c!+ c!  single  cmd 3 + c@ ;
: rd   ( cmd addr count)  ss-bulk-setup  bulk-read ;
: wr   ( cmd addr count)  ss-bulk-setup  bulk-write ;

: +prog
   0ac 5300 0 ss  cmd 2 + c@ ;

.then  ( at89lp-ss)


( Let's try the atmega324.)
.ifdef avr
: tt
   clock-init  led-init  spi-init  flash-leds
   rst/  sck\ ;

: avr-bulk-setup  ( cmd addr toggle count)
   count h!  shuffle  cmd c!+ c!+ c!+ c! ;

: avr   ( cmd addr data)  shuffle  cmd c!+ c!+ c!+ c!  single ;
: avr2  ( cmd addr data - r2)  avr  addr-lo c@ ;
: avr3  ( cmd addr data - r3)  avr  result c@ ;

: rd   ( cmd addr toggle count)  avr-bulk-setup  bulk-read ;
: wr   ( cmd addr toggle count)  avr-bulk-setup  bulk-write ;

: +prog
   rst\  3_0000 wait  0ac 53_00 0 avr2 ;

: -prog  rst/ ;

: status
   0f0 0 0 avr3 ;

: read-sig
   30 0 0 avr3
   30 1 0 avr3
   30 2 0 avr3 ;

: read-fuses
   50 00_00 0 avr3
   58 08_00 0 avr3
   50 08_00 0 avr3 ;

: read-lock
   58 0 0 avr3 ;

.then  ( avr)

.then  ( testing (interactive)
