( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

loading Atmel SPI flash programming (STM32 core)

( It might seem rather odd that this is here, but I'm interested in using
  an STM32 Discovery board as a "programming pod" for Atmel 8051 and AVR
  microcontrollers, which have a simple SPI interface for erasing,
  programming, and reading the on-chip memories and configuration bytes.

  The AVR and AT89LP [Atmel's 8051 variant] have similar but not identical
  command protocols. I'm thinking of leaving the details to the host, and
  putting just the "plumbing" here.

  The idea is basically this:

  [1] the STM32 chip sits in a loop, reading a word of the RAM until a
  magic number appears there. This is the "semaphore" signal from the host
  that a command packet is available. When it sees the magic word, it goes
  to step 2.

  [2] The STM32 turns around and talks to the target chip via SPI, sending
  the command, address, and any data bytes to the target, and reading its
  response. It buffers the response, and then writes a different magic number
  to the semaphore word, signaling the host that it has completed the
  command.

  Then it goes back to [1]. The host reads the buffered target response,
  creates a new command packet, and sets the semaphore word.

  The communication between the STM32 and the host can be over ST-LINK,
  which means that no USB-serial interface is necessary. The STM32 Discovery
  board can power the target as well.

  There is no need to flash this code into the STM32. It can easily run
  from RAM.)

__meta
decimal

( The ST-LINK code will have written some flash programming routines into
  ram. We don't need these, so let's back up over them and start fresh.)

ram  wipe

( We want to put the data structures that the host will use to communicate
  with the STM32 at the beginning of RAM so we know where to find them.
  Remember: when *using* this code, the host will have loaded AVR or 8051
  code into the memory spaces. It will have no idea about how the memory of
  the STM32 is laid out, so we set up a simple, constant layout - data first,
  then the program.)

( Let's put the big stuff first. Makes it easy to find when debugging.)
here equ data        256 allot  ( memory read/write buffer)
here equ semaphore  cell allot  ( semaphore + stm32 command)

here equ cmd           1 allot  ( flash command)
here equ addr                   ( flash addr)
here equ addr-hi       1 allot
here equ addr-lo       1 allot
here equ result                 ( single byte result)
here equ toggle        1 allot  ( flash command toggle - for AVR)
here equ count                  ( byte count to transfer)
here equ out-count     2 allot  ( byte count to write)
here equ in-count      2 allot  ( byte count to read)

hex

( We want to write this code in Forth, so let's load the Forth kernel.)
ld target/ARM/v6-m/kernel-itc.mu4

-- ------------------------------------------------------------------------
-- Chip init
-- ------------------------------------------------------------------------
.ifdef stm32f072
   #48,000,000 equ cpuclk
   ld target/ARM/stm32/f0/72_b-init.mu4
.then
.ifdef stm32f303
   #72,000,000 equ cpuclk
   ld target/ARM/stm32/f3/03_c-init.mu4
.then

: spi-init
   -- First, enable clocks to Port B. We are using SPI1 on pins PB3, PB4, and
   -- PB5, and using PB6 and PB7 as GPIO pins (target /SS, target /RST, resp.)
   ( Ports -FED_CBA- )
        [ %0000_0100  #16 << #] RCC_AHBENR set!

   -- Clear port B
   0 GPIOB_ODR !
   -- Set PB3, 5, 6, and 7 to output.
   0 GPIOB_MODER !
   [ %0101_0100_01  3 2* << #] GPIOB_MODER set!  ( 2 bits per pin)
   -- Set output speed to medium.
   0 GPIOB_OSPEEDR !
   [ %0101_0100_01  3 2* << #] GPIOB_OSPEEDR set!  ( 2 bits per pin) ;

-- --------------------------------------------------------------------
-- SPI building blocks
-- --------------------------------------------------------------------
: bit/  ( bit)  GPIOB_BSRR ! ;
: bit\  ( bit)  GPIOB_BRR ! ;

( SCK on PB3.)
: sck/   [ 1 3 << #] bit/ ;
: sck\   [ 1 3 << #] bit\ ;

( Half cycle delay. Needed to slow the clock down a bit.)
: H ;

( Do one clock cycle, including any delays.)
: sck/\   sck/ H sck\ ;

( XXX Do we care that bit! and bit@, written in Forth, are rather slow? If
  we wanted to bitbang faster, these should be code words.)

( MISO on PB4.)
: bit@   ( bits - bits')
   2*  GPIOB_IDR @  4 >>  1 and  + ;

( Amusing note: The standard Forth-style pronunciation of bit! is "bit bang". ;-)

( MOSI on PB5.)
: bit!   ( bits - bits')  ( sample hi bit - 80 - and drive MOSI with it)
   dup  [ 1 5 << #]  GPIOB_BRR ( bit clear register)
   rot 80 and  if  [ GPIOB_BSRR GPIOB_BRR - #] + ( bit set register)  then  !
   2* ;

( /SS on PB6.)
: ss/  ( de-assert /SS)   [ 1 6 << #] bit/ ;
: ss\  ( assert /SS)      [ 1 6 << #] bit\ ;

( /RST on PB7.)
: rst/  ( de-assert /RST)   [ 1 7 << #] bit/ ;
: rst\  ( assert /RST)      [ 1 7 << #] bit\ ;

( Write a byte.)
: >s   ( b)
   8 for  bit!  sck/\  next  drop ;

( Read a byte.)
: s>   ( - b)
   0  8 for  bit@  sck/\  next ;

( Write and read a byte.)
: >s>  ( out - in)
   0 swap  8 for  bit!  swap bit@ swap  sck/\  next  drop ;


( Since we are going to be reading a buffer sent to us by the host, let's
  have nice words for that.)

variable p
: p@   p @  c@       ;  ( read next byte from buf, don't incr)
: p*   p @  c@+  p ! ;  ( read next byte from buf, incr)
: p&   p @  c!+  p ! ;  ( write next byte to buf, incr)

: >p>   p@ >s> p& ;     ( read from buf, send byte, recv byte, write to buf)
:  p>       s> p& ;     ( send dummy byte, recv byte, write to buf)
: >p    p* >s     ;     ( read from buf, send byte, recv and discard byte)

-- ------------------------------------------------------------------------
-- Jump tables
-- ------------------------------------------------------------------------
: (dispatch)  ( index)
   1+ cells r@ +
   dup r@ @ u< if  r> drop  @execute ^  then
   drop  r> @ >r  ( skip jump table and keep executing) ;

compiler: [:  ( start a jump table)
   \t (dispatch) ,  here  0 , ( ip past last cfa) ;

compiler: :]  ( end a jump table)
   here  swap  image-! ;


.ifdef avr
-- ------------------------------------------------------------------------
-- AVR programming
-- ------------------------------------------------------------------------
: send-cmd
   ( Save data pointer, send cmd and addr, restore data pointer.)
   p @  cmd p !  >p >p >p  p !
   ( Toggle cmd.)
   toggle c@  cmd c@  over xor  dup cmd c!
   ( If cmd toggled to zero, or if toggle *is* zero, incr addr-lo.)
   and 0= if  addr-lo dup c@ 1+  swap c!  then ;

: setup-bulk  ( - count)  data p !  count h@ ;

( The three transaction types to define: single, bulk-read, bulk-write.)
: single      cmd p !  >p> >p> >p> >p> ;
: bulk-read   setup-bulk  for  send-cmd  p>  next ;
: bulk-write  setup-bulk  for  send-cmd  >p  next ;

.then  ( avr)


.ifdef at89lp
-- ------------------------------------------------------------------------
-- AT89LP programming using fixed-length payloads, no prefix, no /SS
-- ------------------------------------------------------------------------
( Mostly for the AT89LP51/52.)

( This version does *not* use /SS or the 0aa 55 prefix, and the data
  payload is always either 1 byte or 64 bytes.)

( TODO)
( The three transaction types to define: single, bulk-read, bulk-write.)
: single ;
: bulk-read ;
: bulk-write ;

.then  ( at89lp)


.ifdef at89lp-ss
-- ------------------------------------------------------------------------
-- AT89LP programming using variable-length payload, command prefix, and /SS
-- ------------------------------------------------------------------------
( For AT89LP828, 3240, 6440.)

( This version uses SPI slave select [/SS] to bracket the command packet,
  and also prefixes every command with 0aa 55.)

( Start an SPI packet, send the prefix bytes, setup command buffer.)
: <pkt   ss\  0aa >s  55 >s  cmd p ! ;

( End a programming packet.)
: pkt>   ss/ ;

( Send cmd, addr-hi, and addr-lo, discarding responses. Setup data buffer.)
: setup-bulk  ( - count)  <pkt  >p >p >p  data p !  count h@ ;

( The three transaction types to define: single, bulk-read, bulk-write.)

( Send cmd, addr-hi, addr-lo, and one dummy byte, saving all responses.)
: single       <pkt  >p> >p> >p> p>  pkt> ;

( For bulk commands, send cmd and address bytes, then send or recv a
  buffer of data.)

: bulk-read    setup-bulk  for  p>  next  pkt> ;
: bulk-write   setup-bulk  for  >p  next  pkt> ;

.then  ( at89lp-ss)


-- ------------------------------------------------------------------------
-- Serial communication
-- ------------------------------------------------------------------------
: uart-init
   -- First, enable clocks to Port A. We are using uart1 on pins PA9 and PA10.
   [ 1 #17 << #] RCC_AHBENR set!

   -- Enable clocks to uart1 as well.
   [ 1 #14 << #] RCC_APB2ENR set!

   -- Set mode bits (%10) and alternate function (AF1) for uart.
   [ %1010 #9       2*  << #] GPIOA_MODER set!  ( 2 bits per pin)
   [    11 #9  8 -  4 * << #] GPIOA_AFRH set!   ( 4 bits per pin)

   -- Now for the uart itself.
   USART1_CR1  0 over ! ( reset and disable USART)
   %1100 ( TE+RE) ( enable tx and rx)  over set!
   [ cpuclk #38,400 / #] USART1_BRR !
   1 ( UE) ( enable USART)  swap set! ;

: ?status  ( bit)
   begin  USART1_ISR @  over and  until  drop ;

: uart-recv  ( - b)   [ 1 #5 << ( RXNE bit) #] ?status  USART1_RDR @ ;
: uart-send  ( b)     [ 1 #7 << ( TXE bit)  #] ?status  USART1_TDR ! ;

: uart-send-recv
   data p !  out-count h@ for  p* uart-send  next
   data p !   in-count h@ for  uart-recv p&  next ;


-- ------------------------------------------------------------------------
-- Core command processing loop
-- ------------------------------------------------------------------------
( XXX forget about changing clock speed for now.)
: fast-clock ;
: slow-clock ;

( Command index is above the word that it executes.)
: do-command  ( n)
           ( 10    11       12           13 )
   10 - [:  rst\  rst/  slow-clock  fast-clock
           (  14       15         16 )
            single  bulk-read  bulk-write
           (      17 )
            uart-send-recv  :] ;

here ]  ( chip-init)
   clock-init  led-init  spi-init  uart-init  flash-leds
   fast-clock  ss/  rst/  sck\
   begin
      face_d000 semaphore !  ( ready for another command)
      0  begin  drop  semaphore @  dup ffff_ff00 and  deca_f000 =  until
      0ff and  ( command byte)  do-command
   again [

( Startup code! Since we have a Forth kernel, let's write the startup code
  in Forth!)

label startup
   ( Ignore the sp we were passed. Set rp to top of ram, sp below.)
   @ram #ram + rp lit   rp sp mov   #64 cells # sp sp sub
   cpsid  ( disable interrupts)
   ( chip-init)  ip  lit
   deca_fbad     top lit
   next  ;c
   pool,


( XXX The following is for interactive testing and needs to go away
  eventually.)

.ifdef testing

: >lohi  ( w - lo hi)
   dup  0ff and  swap 8 >> ;

: >hilo  ( w - hi lo)
   >lohi swap ;

: shuffle  ( cmd addr data - data addr-lo addr-hi cmd)
   -rot  >lohi  rot ;

: index  ( offset)
   100 0 do  dup i +   i data + c!  loop  drop ;

: wipe
   100 0 do  0ff i data + c!  loop ;

.ifdef at89lp-ss

( Testing. Set things up as if for an at89lp chip.)
: tt
   clock-init  led-init  spi-init  flash-leds
   ss/  sck\ ;

: ss-bulk-setup  ( cmd addr count)  count h!  >lohi rot  cmd  c!+ c!+ c! ;
: ss   ( cmd addr data)   shuffle  cmd c!+ c!+ c!+ c!  single  cmd 3 + c@ ;
: rd   ( cmd addr count)  ss-bulk-setup  bulk-read ;
: wr   ( cmd addr count)  ss-bulk-setup  bulk-write ;

: +prog
   0ac 5300 0 ss  cmd 2 + c@ ;

.then  ( at89lp-ss)


( Let's try the atmega324.)
.ifdef avr
: tt
   clock-init  led-init  spi-init  flash-leds
   rst/  sck\ ;

: avr-bulk-setup  ( cmd addr toggle count)
   count h!  shuffle  cmd c!+ c!+ c!+ c! ;

: avr   ( cmd addr data)  shuffle  cmd c!+ c!+ c!+ c!  single ;
: avr2  ( cmd addr data - r2)  avr  addr-lo c@ ;
: avr3  ( cmd addr data - r3)  avr  result c@ ;

: rd   ( cmd addr toggle count)  avr-bulk-setup  bulk-read ;
: wr   ( cmd addr toggle count)  avr-bulk-setup  bulk-write ;

: +prog
   rst\  3_0000 wait  0ac 53_00 0 avr2 ;

: -prog  rst/ ;

: status
   0f0 0 0 avr3 ;

: read-sig
   30 0 0 avr3
   30 1 0 avr3
   30 2 0 avr3 ;

: read-fuses
   50 00_00 0 avr3
   58 08_00 0 avr3
   50 08_00 0 avr3 ;

: read-lock
   58 0 0 avr3 ;

.then  ( avr)

.then  ( interactive)
