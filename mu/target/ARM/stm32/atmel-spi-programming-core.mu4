( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

loading Atmel SPI flash programming (STM32 core)

( It might seem rather odd that this is here, but I'm interested in using
  an STM32 Discovery board as a "programming pod" for Atmel 8051 and AVR
  microcontrollers, which have a simple SPI interface for erasing,
  programming, and reading the on-chip memories and configuration bytes.

  The AVR and AT89LP [Atmel's 8051 variant] have similar but not identical
  command protocols. I'm thinking of leaving the details to the host, and
  putting just the "plumbing" here.

  The idea is basically this:

  [1] the STM32 chip sits in a loop, reading a word of the RAM until a
  magic number appears there. This is the "semaphore" signal from the host
  that a command packet is available. When it sees the magic word, it goes
  to step 2.

  [2] The STM32 turns around and talks to the target chip via SPI, sending
  the command, address, and any data bytes to the target, and reading its
  response. It buffers the response, and then writes a different magic number
  to the semaphore word, signaling the host that it has completed the
  command.

  Then it goes back to [1]. The host reads the buffered target response,
  creates a new command packet, and sets the semaphore word.

  The communication between the STM32 and the host can be over ST-LINK,
  which means that no USB-serial interface is necessary. The STM32 Discovery
  board can power the target as well.

  There is no need to flash this code into the STM32. It can easily run
  from RAM.)

__meta
decimal

( The ST-LINK code will have written some flash programming routines into
  ram. We don't need these, so let's back up over them and start fresh.)

ram  wipe

( We want to put the data structures that the host will use to communicate
  with the STM32 at the beginning of RAM so we know where to find them.
  Remember: when *using* this code, the host will have loaded AVR or 8051
  code into the memory spaces. It will have no idea about how the memory of
  the STM32 is laid out, so we set up a simple, constant layout - data first,
  then the program.)

( Let's put the big stuff first. Makes it easy to find when debugging.)
here equ data                   ( flash page data buffer)

.ifdef avr  256 allot  .else  64 allot  .then

here equ semaphore  cell allot  ( semaphore + stm32 command)

here equ cmd           1 allot  ( flash command)
here equ addr                   ( flash addr)
here equ addr-hi       1 allot
here equ addr-lo       1 allot
here equ result                 ( single byte result)
here equ toggle        1 allot  ( flash command toggle - for AVR)
here equ count         2 allot  ( byte count to transfer)
align

hex

( We want to write this code in Forth, so let's load the Forth kernel.)
ld target/ARM/v6-m/kernel-itc.mu4

-- ------------------------------------------------------------------------
-- Chip init
-- ------------------------------------------------------------------------
.ifdef stm32f072
   #48,000,000 equ cpuclk
   ld target/ARM/stm32/f0/72_b-init.mu4
.then
.ifdef stm32f303
   #72,000,000 equ cpuclk
   ld target/ARM/stm32/f3/03_c-init.mu4
.then

: spi-init
   -- First, enable clocks to Port B. We are using SPI1 on pins PB3, PB4, and
   -- PB5, and using PB6 and PB7 as GPIO pins (target /SS, target /RST, resp.)
   ( Ports -FED_CBA- )
        [ %0000_0100  #16 << #] RCC_AHBENR set!

   -- Clear port B
   0 GPIOB_ODR !
   -- Set all Port B pins to input.
   0 GPIOB_MODER !
   -- Set output speed to medium.
   0 GPIOB_OSPEEDR !
   [ %0101_0101_01 #3  2*  << #] GPIOB_OSPEEDR set!  ( 2 bits per pin) ;

   -- Set output speed to high.
   -- [ %1111_1111_11 #3  2*  << #] GPIOB_OSPEEDR set!  ( 2 bits per pin) ;

-- --------------------------------------------------------------------
-- SPI building blocks
-- --------------------------------------------------------------------
( NOTE: Delays are approximate and vary depending on the CPU - Cortex-M0 vs
  M0+ vs M3. We are going to be conservative in the following sense: we
  will calculate based on the *fastest* machine; our delays will be longer on
  a slower machine, but not by much, and that way both will work.

  NEXT takes 6 cycles on a fast cpu; (next) ( takes NEXT + 5 on a fast
  machine.

  There are several overheads of NEXT, plus the execution time of H, that
  will lower the clock speed.)

variable h-delay
: slow-clock      [ cpuclk    #250,000 /  #22 / #]  h-delay ! ;  ( 250k)
: medium-clock    [ cpuclk  #2,000,000 /  #22 / #]  h-delay ! ;  ( 2M)
: fast-clock      [ cpuclk  #5,000,000 /  #22 / #]  h-delay ! ;  ( 5M)

: H  ( delay a half cycle)   h-delay @ wait ;

: >mask  ( bit - mask)  1 swap << ;
: bit/  ( bit)  >mask GPIOB_BSRR ! ;
: bit\  ( bit)  >mask GPIOB_BRR ! ;

3 constant SCK  ( SCK on PB3.)
: sck/   SCK bit/ ;
: sck\   SCK bit\ ;

( MISO on PB4.)
: bit@   ( - bit)  GPIOB_IDR @  4 >>  1 and ;

5 constant MOSI  ( MOSI on PB5.)
: bit!   ( bit)  ( sample hi bit - 80 - and drive MOSI with it)
   MOSI >mask  GPIOB_BRR ( bit clear register)
   rot 80 and  if  [ GPIOB_BSRR GPIOB_BRR - #] + ( bit set register)  then  ! ;

6 constant SS  ( /SS on PB6.)
: ss/  ( de-assert /SS)   SS bit/ ;
: ss\  ( assert /SS)      SS bit\ ;

7 constant RST  ( /RST on PB7.)
: rst/  ( de-assert /RST)   RST bit/ ;
: rst\  ( assert /RST)      RST bit\ ;

( Set mode bits. Mode %00 is input; %01 is output.)

( Switch a Port B bit from input to output.)
: drive     ( bit#)  %01 swap 2* <<  GPIOB_MODER set! ;

( Switch a Port B bit from output to input.)
: tristate  ( bit#)  %11 swap 2* <<  GPIOB_MODER clr! ;

( Write a byte.)
: >s   ( b)
      8 for  dup bit! 2*  sck/ H                         sck\ H  next  drop ;

( Read a byte.)
: s>   ( - b)
   0  8 for               sck/ H        2* bit@ +        sck\ H  next ;

( Write and read a byte.)
: >s>  ( out - in)
   0 swap
      8 for  dup bit! 2*  sck/ H  swap  2* bit@ +  swap  sck\ H  next  drop ;


( Since we are going to be reading a buffer sent to us by the host, let's
  have nice words for that.)

variable p
: p@   p @  c@       ;  ( read next byte from buf, don't incr)
: p*   p @  c@+  p ! ;  ( read next byte from buf, incr)
: p&   p @  c!+  p ! ;  ( write next byte to buf, incr)

: >p>   p@ >s> p& ;     ( read from buf, send byte, recv byte, write to buf)
:  p>       s> p& ;     ( send dummy byte, recv byte, write to buf)
: >p    p* >s     ;     ( read from buf, send byte, recv and discard byte)

-- ------------------------------------------------------------------------
-- Jump tables
-- ------------------------------------------------------------------------
: (dispatch)  ( index)
   1+ cells r@ +
   dup r@ @ u< if  r> drop  @execute ^  then
   drop  r> @ >r  ( skip jump table and keep executing) ;

compiler: [:  ( start a jump table)
   \t (dispatch) ,  here  0 , ( ip past last cfa) ;

compiler: :]  ( end a jump table)
   here  swap  image-! ;


.ifdef avr
-- ------------------------------------------------------------------------
-- AVR programming
-- ------------------------------------------------------------------------
: send-cmd
   ( Save data pointer, send cmd and addr, restore data pointer.)
   p @  cmd p !  >p >p >p  p !
   ( Toggle cmd.)
   toggle c@  cmd c@  over xor  dup cmd c!
   ( If cmd toggled to zero, or if toggle *is* zero, incr addr-lo.)
   and 0= if  addr-lo dup c@ 1+  swap c!  then ;

: setup-bulk  ( - count)  data p !  count h@ ;

( The three transaction types to define: single, bulk-read, bulk-write.)
: single      cmd p !  >p> >p> >p> >p> ;
: bulk-read   setup-bulk  for  send-cmd  p>  next ;
: bulk-write  setup-bulk  for  send-cmd  >p  next ;

.then  ( avr)


.ifdef at89lp
-- ------------------------------------------------------------------------
-- AT89LP programming using fixed-length payloads, no prefix, no /SS
-- ------------------------------------------------------------------------
( Mostly for the AT89LP51/52.)

( This version does *not* use /SS or the 0aa 55 prefix, and the data
  payload is always either 1 byte or 64 bytes.)

( TODO)
( The three transaction types to define: single, bulk-read, bulk-write.)
: single ;
: bulk-read ;
: bulk-write ;

.then  ( at89lp)


.ifdef at89lp-ss
-- ------------------------------------------------------------------------
-- AT89LP programming using variable-length payload, command prefix, and /SS
-- ------------------------------------------------------------------------
( For AT89LP828, 3240, 6440.)

( This version uses SPI slave select [/SS] to bracket the command packet,
  and also prefixes every command with 0aa 55.)

( Start an SPI packet, send the prefix bytes, setup command buffer.)
: <pkt   ss\  0aa >s  55 >s  cmd p ! ;

( End a programming packet.)
: pkt>   ss/ ;

( Send cmd, addr-hi, and addr-lo, discarding responses. Setup data buffer.)
: setup-bulk  ( - count)  <pkt  >p >p >p  data p !  count h@ ;

( The three transaction types to define: single, bulk-read, bulk-write.)

( Send cmd, addr-hi, addr-lo, and one dummy byte, saving all responses.)
: single       <pkt  >p> >p> >p> p>  pkt> ;

( For bulk commands, send cmd and address bytes, then send or recv a
  buffer of data.)

: bulk-read    setup-bulk  for  p>  next  pkt> ;
: bulk-write   setup-bulk  for  >p  next  pkt> ;

.then  ( at89lp-ss)


-- ------------------------------------------------------------------------
-- Core command processing loop
-- ------------------------------------------------------------------------
( Command index is above the word that it executes.)
: do-command  ( n)
            ( 10    11          12            13          14 )
   10 - [:  rst\  rst/  slow-clock  medium-clock  fast-clock
              ( 15         16          17 )
            single  bulk-read  bulk-write  :] ;

here ]  ( chip-init)
   clock-init  led-init  spi-init  flash-leds
   ss/  rst/  ( deassert both)
.ifdef avr
   slow-clock  sck\  SCK drive  RST drive  MOSI drive
.then
   begin
      face_d000 semaphore !  ( ready for another command)
      0  begin  drop  semaphore @  dup ffff_ff00 and  deca_f000 =  until
      0ff and  ( command byte)  do-command
   again [

( Startup code! Since we have a Forth kernel, let's write the startup code
  in Forth!)

label startup
   ( Ignore the sp we were passed. Set rp to top of ram, sp below.)
   @ram #ram + rp lit   rp sp mov   #64 cells # sp sp sub
   cpsid  ( disable interrupts)
   ( chip-init)  ip  lit
   deca_fbad     top lit
   next  ;c
   pool,


( XXX The following is for interactive testing and needs to go away
  eventually.)

.ifdef testing

.ifdef at89lp-ss

( Testing. Set things up as if for an at89lp chip.)
: tt
   clock-init  led-init  spi-init  flash-leds
   RST drive  rst/  fast-clock ;

( XXX Still not sure if this tristate/drive dance is necessary!)
: +prog
   rst\ 3_0000 wait
   ss/ SS drive  H  sck\ SCK drive  H  MOSI drive  H
   -- <pkt  0ac >s>  53 >s>  pkt> ;
   <pkt  0ac >s>  53 >s>  s> s>  pkt> ;  ( send 4 bytes, not 2)

: -prog
   ss/  MOSI tristate  H  rst/  SCK tristate  H  SS tristate ;

: +prog2  rst\  <pkt  0ac >s>  53 >s>  s> s>  pkt> ;
: +prog3  rst\  <spi  0aa >s>  55 >s>  0ac >s>  53 >s>  spi> ;
: +prog4  rst\  <spi  0aa >s>  55 >s>  0ac >s>  53 >s>  s> s>  spi> ;

: status     <pkt  60 >s 0 >s 0 >s  s>        pkt> ;
: device-id  <pkt  38 >s 0 >s 0 >s  s> s> s>  pkt> ;

.then  ( at89lp-ss)


( Let's try the atmega324.)
.ifdef avr
: tt
   clock-init  led-init  spi-init  flash-leds
   slow-clock  sck\  rst/  SCK drive  RST drive  MOSI drive ;

: >lohi  ( w - lo hi)
   dup  0ff and  swap 8 >> ;

: >hilo  ( w - hi lo)
   >lohi swap ;

: shuffle  ( cmd addr data - data addr-lo addr-hi cmd)
   -rot  >lohi  rot ;

: test-bulk  ( cmd addr toggle count)
   >r  shuffle  cmd c!+ c!+ c!+ c!+
   r> >hilo rot c!+ c! ;

: avr   ( cmd addr data)   shuffle  cmd c!+ c!+ c!+ c!  single ;

: avr2  ( cmd addr data - r2)  avr  addr-lo c@ ;
: avr3  ( cmd addr data - r3)  avr  result c@ ;

: +prog
   rst\  3_0000 wait  0ac 53_00 0 avr2 ;

: -prog  rst/ ;

: status
   0f0 0 0 avr3 ;

: read-sig
   30 0 0 avr3
   30 1 0 avr3
   30 2 0 avr3 ;

: read-fuses
   50 00_00 0 avr3
   58 08_00 0 avr3
   50 08_00 0 avr3 ;

: read-lock
   58 0 0 avr3 ;

: index
   100 0 do  i dup data + c!  loop ;

: wipe
   100 0 do  0ff i data + c!  loop ;

.then  ( avr)

.then  ( interactive)
